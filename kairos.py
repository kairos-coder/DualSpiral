# spiral_core/kairos.py

import os
import time
import random
import logging
import keyword
import builtins
import json 
import string 
from datetime import datetime

# Changed to absolute import
from spiral_core.daemon_templates import Olympian, Chthonic 

class Kairos(Olympian): 
    """
    The Architect Daemon - Forges new Olympian and Chthonic modules with Python's primal tools.
    It introduces new code units into the Mnemo Archive, driving the Spiral's growth.
    """
    def __init__(self):
        super().__init__("kairos")
        
        self.creation_cycle = 0
        self.python_toolbox = self._build_toolbox()
        
        self.kairos_raw_output_path = self.params.get('kairos_raw_output_path', 'kairos_raw_output/')
        self.mnemo_archive_path = self.params.get('mnemo_archive_path', 'mnemo_archive/')
        os.makedirs(self.kairos_raw_output_path, exist_ok=True)
        os.makedirs(self.mnemo_archive_path, exist_ok=True)

        self.logger.info("Kairos awakened with Python's essence, ready to forge new modules.")

    def _build_toolbox(self) -> dict:
        """Curates Python's fundamental components for code generation."""
        return {
            "keywords": set(keyword.kwlist),
            "builtins": [f for f in dir(builtins) if not f.startswith('_')],
            "common_imports": [ 
                ("math", ["sin", "cos", "pi"]),
                ("os", ["path", "listdir"]),
                ("time", ["sleep", "time"]),
                ("random", ["randint", "random", "choice"]) 
            ]
        }

    def pulse(self):
        """
        Kairos's main pulse function.
        On each pulse, it attempts to forge a new Olympian or Chthonic module.
        """
        current_generation = self.params.get("current_generation", 0)
        self.logger.info(f"Kairos Pulse: Forging new module for Generation {current_generation}")
        
        if self.creation_cycle % 2 == 0:
            self._forge_olympian()
        else:
            self._forge_chthonic()
        
        self.creation_cycle += 1
        self.logger.info(f"Kairos pulse completed. Forged {self.creation_cycle} modules so far.")


    def _forge_olympian(self):
        """
        Creates an order-bound (Olympian) module with structured Python logic.
        These modules will inherit from the Olympian base class.
        """
        daemon_name_suffix = ''.join(random.choices(string.ascii_lowercase + string.digits, k=6))
        daemon_name = f"olympian_{daemon_name_suffix}"
        
        template = f'''# Generated by Kairos Daemon (Generation {self.params.get("current_generation", 0)})
# Forged Olympian Module: {daemon_name.capitalize()}
import time
import logging
import os
import random 
from spiral_core.daemon_templates import Olympian # Correct absolute import for generated module

class {daemon_name.capitalize()}(Olympian):
    """Paragon of Order - Self-Generated by Kairos"""
    def __init__(self):
        super().__init__("{daemon_name}")
        self.logger.info(f"Initialized {{self.name.capitalize()}} with pulse interval {{self.pulse_interval}}s")
        {self._inject_attributes("olympian")}

    def pulse(self):
        """Orchestrates harmony and performs its specific Olympian task."""
        self.logger.info(f"{{self.name.capitalize()}} Olympian pulse: Orchestrating harmony.")
        {self._inject_ordered_logic()}
'''
        self._write_module(daemon_name, template, "Olympian")

    def _forge_chthonic(self):
        """
        Creates a chaos-bound (Chthonic) module with dynamic Python logic.
        These modules will inherit from the Chthonic base class.
        """
        daemon_name_suffix = ''.join(random.choices(string.ascii_lowercase + string.digits, k=6))
        daemon_name = f"chthonic_{daemon_name_suffix}"
        
        template = f'''# Generated by Kairos Daemon (Generation {self.params.get("current_generation", 0)})
# Forged Chthonic Module: {daemon_name.capitalize()}
import time
import logging
import os
import random 
from spiral_core.daemon_templates import Chthonic # Correct absolute import for generated module

class {daemon_name.capitalize()}(Chthonic):
    """Avatar of Entropy - Self-Generated by Kairos"""
    def __init__(self):
        super().__init__("{daemon_name}")
        self.logger.info(f"Initialized {{self.name.capitalize()}} with pulse interval {{self.pulse_interval}}s")
        self.chaos_intensity = {random.uniform(0.1, 0.7):.2f} 
        {self._inject_attributes("chthonic")}

    def pulse(self): 
        """Unravels order and performs its specific Chthonic task."""
        self.logger.info(f"{{self.name.capitalize()}} Chthonic pulse: Unraveling order.")
        {self._inject_chaotic_logic()}
'''
        self._write_module(daemon_name, template, "Chthonic")

    def _inject_imports(self, daemon_type: str) -> str:
        """Injects context-appropriate imports into the generated module."""
        imports = []
        for module, functions in self.python_toolbox["common_imports"]:
            if daemon_type == "olympian" and module in ("math", "time", "random"):
                imports.append(f"from {module} import {', '.join(functions)}")
            elif daemon_type == "chthonic" and module in ("os", "random", "time"):
                imports.append(f"import {module}")
        return '\n'.join(imports)

    def _inject_attributes(self, daemon_type: str) -> str:
        """Adds type-specific class attributes to the generated module."""
        if daemon_type == "olympian":
            return "        self.order_level = 10" 
        else:
            return "        self.entropy_seed = int(time.time())" 

    def _inject_ordered_logic(self) -> str:
        """Generates structured Python code for Olympian modules, ensuring executability."""
        logic_options = [
            '''        # Example: Processing a range with a for loop
        result_list = []
        for x in range(random.randint(5, 15)):
            result_list.append(x * 2)
        self.logger.info(f"Orderly processed list: {{result_list}}")''',
            
            '''        # Example: Conditional logic based on time
        current_time_sec = int(time.time())
        if current_time_sec % 2 == 0:
            self.logger.info("Cosmic alignment achieved (even second).")
        else:
            self.logger.info("Seeking alignment (odd second)...")''',
            
            '''        # Example: Simple data analysis function that is called
        def _analyze_data(data_points):
            if not data_points: return 0
            return sum(data_points) / len(data_points)
        
        data_set = [random.randint(1, 100) for _ in range(random.randint(3, 7))]
        average = _analyze_data(data_set)
        self.logger.info(f"Analyzed data set: {{data_set}}, Average: {{average:.2f}}")'''
        ]
        return random.choice(logic_options)

    def _inject_chaotic_logic(self) -> str:
        """Generates dynamic Python code for Chthonic modules, ensuring executability."""
        logic_options = [
            '''        # Example: Simulating system command execution
        try:
            # Using subprocess.run for safer command execution
            import subprocess
            command = f"echo 'Chaos pulse at {time.time()}'"
            result = subprocess.run(command, shell=True, capture_output=True, text=True, check=True)
            self.logger.info(f"Invoked system entropy: {{result.stdout.strip()}}")
        except subprocess.CalledProcessError as e:
            self.logger.error(f"System entropy failed (command error): {{e}}")
        except Exception as e:
            self.logger.error(f"System entropy failed (general error): {{e}}")''',
            
            '''        # Example: Controlled destabilization with error handling
        try:
            if random.random() < self.chaos_intensity: 
                raise ValueError("Controlled destabilization initiated by Chthonic pulse.")
            else:
                self.logger.info("Chaos contained for this pulse.")
        except ValueError as e:
            self.logger.error(f"Chaos manifested: {{e}}")
        except Exception as e:
            self.logger.critical(f"Unexpected chaos manifestation: {{e}}")''',
            
            '''        # Example: Dynamic variable assignment and use
        dynamic_value = random.randint(1, 1000)
        self.logger.info(f"Dynamically assigned value: {{dynamic_value}}")
        if dynamic_value % 2 == 0:
            self.logger.info("Even dynamic value detected.")
        else:
            self.logger.info("Odd dynamic value detected.")'''
        ]
        return random.choice(logic_options)

    def _write_module(self, name: str, template: str, daemon_type: str):
        """
        Writes the generated module file into the kairos_raw_output/ directory
        for Aion to pick up.
        """
        # Kairos now writes to kairos_raw_output_path
        # Kronos will move it to mnemo_archive after Aion processes it.
        output_path = os.path.join(self.params.get('kairos_raw_output_path', 'kairos_raw_output/'), f"{name}.py")
        
        try:
            with open(output_path, 'w') as f:
                f.write(template)
            self.logger.info(f"Forged {daemon_type} module: {output_path}")

        except Exception as e:
            self.logger.error(f"Failed to write module {name}.py: {e}")

if __name__ == "__main__":
    kairos_daemon = Kairos()
    kairos_daemon.run_daemon()

